#!/usr/bin/env python3

# If you're reading this, know that I am not, have never been, nor shall ever
# be a frontend engineer. Being color blind means not giving two fucks about UI
# because, for the most part, no-one in UI gives two fucks about CD users, and
# it breeds a frustration with the entire topic. If you have a problem with the
# way it looks, feel free to express your ideas in the form of a pull request.

#TODO:
# * Get off of port 8000 and use a dynamically-selected port. (Start the server
#   w/o an explicit port and just advertize whatever port the server is given.)
# * Maybe an actual favicon.ico? Just pack it as a string?
# * Allow user to alter packet size. (-s argument) Maybe have multiple sizes in
#   same line? I'm not sure how that graph would look.
# * I don't like organizing the endpoints by numeric index on the python side.
#   I'd rather that just be a UI-side thing, but this way, the command-line order
#   is preserved all the way through to the UI. As I said, I really don't like
#   it.
# * Make events a proper type and translate the event dicts to the instances to
#   save on the hash lookup time.

import argparse
from http.server import BaseHTTPRequestHandler, ThreadingHTTPServer
import json
import math
import re
import secrets
import select
import shutil
from subprocess import Popen, PIPE
from threading import Thread
import time
from urllib.parse import urlparse, parse_qs
import webbrowser

MAX_ENDPOINTS = 5

parser = argparse.ArgumentParser(
  description='pingem [-i interval] endpoint [endpoint [endpoint...]]')
parser.add_argument('-i', '--interval', help='time (as a float) between pings')
parser.add_argument('endpoints', nargs='*',
                    help='IP name or address of target[s]',
                    default=['8.8.8.8'])
cl_args = parser.parse_args()
print(cl_args.endpoints)
print(cl_args)

#TODO: Do something sane if ping isn't found anywhere
ping = shutil.which('ping')
print('using ping binary at:' + ping)

#TODO: Replace the X with an "icon" (a couple lines on canvas.)
row_def = '''
<tr id=tr_raw{y} class=tr_raw>
  <td colspan=3>
    <button class=close_button>X</button> <div class='terminal cell' id=raw_pong{y}></div>
  </td>
</tr>
<tr id=tr_data{y}>
  <td id='graph_container_{y}_0' class='graph_container'>
    <canvas id='data_canvas_{y}_0' class='data_canvas'></canvas>
    <canvas id='label_canvas_{y}_0' class='label_canvas'></canvas>
    <canvas id='cursor_canvas_{y}_0' class='cursor_canvas'></canvas>
  </td>
  <td id='graph_container_{y}_1' class='graph_container'>
    <canvas id='data_canvas_{y}_1' class='data_canvas'></canvas>
    <canvas id='label_canvas_{y}_1' class='label_canvas'></canvas>
    <canvas id='cursor_canvas_{y}_1' class='cursor_canvas'></canvas>
  </td>
</tr>
'''


index = '''
<html>
<head>
<title>pingem v1.0e-20</title>
<style>
  body{background-color:black;color:white;overflow:hidden;}
  .terminal{ display:inline-block; font-family:monospace; }
  .status_row{display:grid;grid-template-columns:24px 1fr 25%;}
  .graph_row{display:grid;grid-template-columns:35% 40% 25%;}
  .graph_container { position:relative; border:1px solid grey; padding:2px; }
  .graph_container > canvas { position:absolute; left:0; top:0; }
  .display_layout{cellpadding:0;border:1;}
  .data_canvas { z-index:0; }
  .label_canvas { z-index:1; }
  .cursor_canvas { z-index:2; }
  .close_button { display:inline-block; }
  #viewport_tracker {
    position:fixed; top:0; left:0; width:100vw; height:100vh;
    overflow:hidden; z-index:-1;
  }
</style>
</head>
<body>
<div id=viewport_tracker height:100vh width:100vw></div>
<table class=display_layout>
  ROWS
</table>
<script type='text/javascript' defer>
class Graph {
  constructor(graph_age, row_index, col_index) {
    this.events = {};
    this.latest_event = -1;
    this.graph_age = graph_age;
    this.newest_timestamp = 0.0;
    this.prev_max_rtt = 0.5;
    this.first_active_event = 0;
    this.data_canvas = document.getElementById('data_canvas_'+row_index+'_'+col_index);
    this.label_canvas = document.getElementById('label_canvas_'+row_index+'_'+col_index);
    this.cursor_canvas = document.getElementById('cursor_canvas_'+row_index+'_'+col_index);
    this.data_context = this.data_canvas.getContext('2d');
    this.label_context = this.label_canvas.getContext('2d');
    this.cursor_context = this.cursor_canvas.getContext('2d');
    this.graph_container = document.getElementById('graph_container_'+row_index+'_'+col_index);

    this.dot_width = 9;
    this.vertical_label_divisions = 5.0;
  }

  set_geometry(width, height) {
    this.width = width;
    this.height = height;

    for(var canvas of [this.data_canvas, this.label_canvas, this.cursor_canvas]) {
      canvas.style.width = this.width;
      canvas.style.height = this.height;
      canvas.width = this.width;
      canvas.height = this.height;
    }

    this.graph_container.width = this.width 
      - 5 /* I've no idea why this is necessary */
      ;
    this.graph_container.height = this.height 
      + 2 /* I've no idea why this is necessary */
      ;
  }

  append(event) {
    let icmp_seq = event['icmp_seq'];

    this.latest_event = Math.max(icmp_seq, this.latest_event);
    this.newest_timestamp = Math.max(event['timestamp'], this.newest_timestamp);

    //There are a few situations we have to deal with here. First, what happens if the 'expected'
    //packet comes first, then the thing actually arrives? Frankly, this should be a TODO:, to
    //make the behavior of ultra-late, post-timeout packets configurable. The default (what is
    //implemented here) is that once a packet's timeout has elapsed, it's lost even if it arrives.

    // If the event already exists, either the actual packet arrived first and we should throw out
    // the timeout packet we just received, or the timeout packet already arrived and we're
    // receiving the (very late) pong from the echo endpoint. In this case, it's timed out ands
    // dropped.
    if(this.events[icmp_seq]) {
      //TODO: later, make the behavior configurable?
    } else {
      this.events[icmp_seq] = event;
    }

    this.redraw();
  }

  draw_event(event_age, rtt, max_rtt) {
    let x = (this.data_canvas.width - this.dot_width) * (1 - event_age/this.graph_age);
    let y = (this.data_canvas.height) * (1 - rtt/max_rtt);

    this.data_context.beginPath();
    this.data_context.moveTo(x,y-this.dot_width/1.5);
    this.data_context.lineTo(x,y+this.dot_width/1.5);
    this.data_context.stroke();
    this.data_context.beginPath();
    this.data_context.moveTo(x,y-this.dot_width/2.5);
    this.data_context.lineTo(x,y+this.dot_width/2.5);
    this.data_context.stroke();
  }

  redraw() {
    // vvvvvvvvv DO NOT CHANGE THE ORDER vvvvvvvvv
    let prev_max_rtt = layout_manager.get_prev_max_rtt();
    let new_max_rtt = 0.0;
    // ^^^^^^^^^ DO NOT CHANGE THE ORDER ^^^^^^^^^

    let width = this.data_canvas.width;
    let height = this.data_canvas.height;

    this.data_context.clearRect(0, 0, width, height);
    this.data_context.globalCompositeOperation='lighter';
    this.data_context.lineWidth = this.dot_width;
    this.data_context.strokeStyle = '#a0a0ff27';

    // We need to go through all of this.events and render each rtt's plot point into the canvas.
    for (var i=this.first_active_event; i<=this.latest_event; i++) {
      if(i in this.events) {
        const event = this.events[i];
        const event_age = this.newest_timestamp - event['timestamp']
        if (event_age > this.graph_age) {
          this.first_active_event++;
        } else {
          if(event['msg_type'] == 'pong') {
            new_max_rtt = Math.max(new_max_rtt, event['rtt']);
            this.draw_event(event_age, event['rtt'], prev_max_rtt);
          }
        }
      }
    }

    this.draw_labels(prev_max_rtt);

    this.prev_max_rtt = new_max_rtt;
  }

  draw_labels(prev_max_rtt) {
    let width = this.data_canvas.width;
    let height = this.data_canvas.height;

    this.label_context.clearRect(0, 0, width, height);
    this.label_context.lineWidth = 1;
    this.label_context.strokeStyle= '#ff6060ff';
    this.label_context.fillStyle= '#ff6060ff';
    this.data_context.globalCompositeOperation='source-over';
    this.label_context.beginPath();
    this.label_context.font = '15px courier new';
    this.label_context.textBaseline = 'top';
    var inc = 1.0/this.vertical_label_divisions;
    for(var k=0.0; k<1.0-(inc/2.0); k+=inc) {
      var y = Math.floor(k*height);
      this.label_context.textAlign = 'left';
      this.label_context.fillText('' + ((1-k)*prev_max_rtt).toFixed(1) + 'ms', 0, y+1);
      this.label_context.textAlign = 'right';
      this.label_context.fillText('' + ((1-k)*100).toFixed(1) + '%', width-1, y+1);
      if(k>0.0) {
        this.label_context.moveTo(0, y);
        this.label_context.lineTo(width-1, y);
      }
    }
    this.label_context.stroke();

  }

  get_prev_max_rtt() {
    return this.prev_max_rtt;
  }
}

class LayoutManager {
  constructor() {
    // Just a map of row index to the command-line endpoint name:
    this.endpoints = {}

    // A 2D map keyed first on row index, then a list of 2 graphs.
    this.graphs = {}

    const resizeObserver = new ResizeObserver(entries => {
      layout_manager.on_resize();
      //TODO: Trigger a redraw of everything that hasn't been drawn in the last 500ms.
    });
    resizeObserver.observe(document.getElementById('viewport_tracker'));

    this.width = window.innerWidth;
    this.height = window.innerHeight;
  }

  get_prev_max_rtt() {
    var prev_max_rtt = 0.0;
    for(const [key, [longspan, unused]] of Object.entries(this.graphs)) {
      prev_max_rtt = Math.max(prev_max_rtt, longspan.get_prev_max_rtt());
    }

    return prev_max_rtt;
  }

  get_row_count() {
    return Object.keys(this.graphs).length;
  }

  on_resize() {
    this.width = window.innerWidth;
    this.height = window.innerHeight;

    /* TODO: better heuristics for the height of "stuff." */
    var num_rows = this.get_row_count();
    var inner_height = this.height
      - 14 /* room for top and bottom borders. TODO: remove magic numbers */
      ;
    this.row_height = Math.floor(this.height / num_rows)
      - 5 * 2 /* room for borders between rows and between raw pongs and graphs */
      ;
    this.pong_height = 26; /* TODO: needs to be dependent upon height of text, border thickness. */
    this.data_height = this.row_height - this.pong_height;

    var inner_width = this.width
      -10 /* rooom for left and right borders. TODO: remove magic numbers */
      ;
    this.data_width = (inner_width / 3 ) /* Three columns. TODO: magic number. */
      - 5 /* room for borders between columns */
      ;

    console.log('setting geometries to ' + this.data_width + ',' + this.data_height);
    for(var index of Object.keys(this.graphs)) {
      if(this.graphs[index] != undefined) {
        /* TODO: how to handle the second column? It's not going to be a Graph type. */
        this.graphs[index][0].set_geometry(this.data_width*2, this.data_height);
      }
    }
  }

  activate_row(index) {
    console.log('activating row ' + index);
    document.getElementById('tr_raw'+index).style.display = 'table-row';
    document.getElementById('tr_data'+index).style.display = 'table-row';

    if(this.graphs[index] == undefined) {
      this.graphs[index] = [
          new Graph(60*90, index, 0),
          undefined];
    }
  }

  deactivate_row(index) {
    console.log('deactivating row ' + index);
    document.getElementById('tr_raw'+index).style.display = 'none';
    document.getElementById('tr_data'+index).style.display = 'none';

    delete(this.graphs[index]);
  }

  handle_endpoints_list(data) {
    console.log('endpoint_list received:', data)
    this.endpoints = {};

    for(let index=0; index<MAX_ENDPOINTS; index++) {
      if(data.endpoints[index]) {
        this.activate_row(index);
        this.endpoints[index] = data.endpoints[index];
      } else {
        this.deactivate_row(index);
      }
    }

    this.on_resize();
    console.log('endpoints:');
    console.log(this.endpoints);
  }

  handle_message(event) {
    if(event.msg_type == 'endpoints') {
      this.handle_endpoints_list(event);
      return;
    }

    let message = '';
    if(event.msg_type == 'expected') {
      message = 'Lost icmp_seq:' + event['icmp_seq'];
    } else if(event.msg_type == 'pong') {
      message = event['raw'];
      //TODO: set event['raw'] to undefined to save the space. I'm leaving it for now for
      // debugging reasons.
    }
    document.getElementById('raw_pong'+event.index).textContent = 
      '[' + this.endpoints[event['index']] + ']  ' + message;

    this.graphs[event['index']][0].append(event);
  }
}

/*TODO: this doesn't really need to be a class.*/
class DataRelay {
  constructor() {
    const stream_url = '/stream/?secret='+SECRET;
    this.event_source = new EventSource(stream_url);
    this.event_source.onmessage = (event) => {
      const json_data=event.data;
      const data = JSON.parse(json_data);
      layout_manager.handle_message(data);
    };
    this.event_source.onerror = (error) => {
      console.error('event_source.onerror:', error);
    };
    console.log('data stream handler is set up');
  }
}

let data_relay = new DataRelay();
let layout_manager = new LayoutManager();

</script>
</body>
'''

secret = secrets.randbelow(1000000000000000)
print('using secret', secret);

def start_browser():
  # give the server a moment to start up. I've never seen this to be necessary,
  # but you never know.
  time.sleep(1.0)
  webbrowser.open(f'http://127.0.0.1:8000?secret={secret}', new=0)

def encode_as_wire_message(data):
  json_encoded = json.dumps(data)
  return bytes('data: ' + json_encoded + '\n\n', 'utf8')

class PingManager():
  def __init__(self, endpoint_names):
    self.successful_response_regex = re.compile(
      r'from ([^:]*):.*seq=(\d*) ttl=(\d*) time=([0-9.]*) ms')

    self.interval = 1.0
    if cl_args.interval:
      self.interval = float(cl_args.interval)

    # We use a dict here because we want to be able to delete an entry without
    # the ide of later entries changing:
    self.endpoints = {};
    for endpoint_name in endpoint_names:
      self.add_endpoint(endpoint_name)


  def add_endpoint(self, endpoint_name):
    #TODO: at startup, work out the location of ping binary
    endpoint_index = None
    for index in range(MAX_ENDPOINTS):
      if index not in self.endpoints:
        endpoint_index = index
        break

    if endpoint_index is None:
      raise "Too many endpoints requested"

    print('ENDPOINT BEING ADDED: ' + endpoint_name)
    self.endpoints[endpoint_index] = {'endpoint_name': endpoint_name}
    self.endpoints[endpoint_index]['subprocess'] = (
      Popen([ping, '-i', str(self.interval), endpoint_name], stderr=PIPE, stdout=PIPE))
    now = time.time()
    self.endpoints[endpoint_index]['start_time'] = now
    self.endpoints[endpoint_index]['last_loss_check_time'] = now

  def get_wide_icmp_seq(self, narrow, endpoint_index):
    now = time.time()
    elapsed = now - self.endpoints[endpoint_index]['start_time']
    #Compute how many 65k runs we should expect to have completed:
    runs = elapsed/(65536.0 * self.interval)
    runs_fract, runs_floor = math.modf(runs)
    runs_floor = int(runs_floor)

    if runs_fract >= 0.8 and narrow < 32768:
        return narrow + (65536 * runs_floor + 1)
    elif runs_fract < 0.2 and narrow > 32768:
        return narrow + (65536 * runs_floor - 1)
    else:
      return narrow + 65536 * runs_floor

  def get_expected_events(self, endpoint_index):
    events = []

    last_time = self.endpoints[endpoint_index]['last_loss_check_time']
    now = time.time()
    time_to_check = now
    while time_to_check > last_time:
      elapsed_time = time_to_check - self.endpoints[endpoint_index]['start_time']

      #TODO: Make the timeout time user-configurable.
      icmp_seq = int((elapsed_time - 3.0)/self.interval)
      if (icmp_seq >= 0):
        data = {'msg_type':'expected'}
        data['icmp_seq'] = icmp_seq
        data['index'] = endpoint_index
        data['timestamp'] = time.time() - self.endpoints[endpoint_index]['start_time']
        events.append(encode_as_wire_message(data))

      time_to_check -= self.interval

    self.endpoints[endpoint_index]['last_loss_check_time'] = now

    return events

  def get_events(self):
    events = []
    for endpoint_index, endpoint_data in self.endpoints.items():
      events += self.get_expected_events(endpoint_index)

      stdouts = [endpoint_data['subprocess'].stdout]

      readable_stdouts, _, _ = select.select(stdouts, [], [])
      for stdout in readable_stdouts:
        line = stdout.readline().decode().strip()
        match = re.search(self.successful_response_regex, line)
        if match:
          data = {}
          data['msg_type'] = 'pong'
          data['responder'] = match.group(1)
          icmp_seq = self.get_wide_icmp_seq(int(match.group(2)), endpoint_index)
          print(self.endpoints[endpoint_index]['endpoint_name'], icmp_seq, line)
          data['icmp_seq'] = icmp_seq
          data['ttl'] = int(match.group(3))
          data['rtt'] = float(match.group(4))
          data['raw'] = line
          data['index'] = endpoint_index
          data['timestamp'] = time.time() - self.endpoints[endpoint_index]['start_time']
          events.append(encode_as_wire_message(data))

    return events

  def get_endpoint_names(self):
    return {k:v['endpoint_name'] for k,v in self.endpoints.items()}

#TODO: Get this constant in the class
class RequestHandler(BaseHTTPRequestHandler):
  def check_secret(self):
    # TODO: get the secret out of the url so it can't be shoulder-surfed. This isn't a sufficiently
    #       critical app to do any real user auth. If the user started the app, that's good enough.
    self.parsed_url = urlparse(self.path)
    self.query_params = parse_qs(self.parsed_url.query)

    if ('secret' not in self.query_params or
        type(self.query_params['secret']) != list or
        int(self.query_params['secret'][0]) != secret):
      return False
    return True

  def add_misc_headers(self, content_type):
    self.send_header('Content-type', content_type)
    self.send_header('Cache-Control', 'no-cache')
    self.send_header('Connection', 'keep-alive')
    self.send_header('Access-Control-Allow-Credentials', 'true')
    self.send_header('Access-Control-Allow-Origin', '*')

  def serve_index(self):
    self.send_response(200)
    self.add_misc_headers('text/html')
    self.end_headers()

    # TODO: Better (django-like?) interpolation? 
    # TODO: I can't use .format w/ index because it freaks out every time it
    # sees a {, which javascript and css kick in all the time. I don't want to
    # have to use \{ every time.....
    rows = ''
    for row_id in range(MAX_ENDPOINTS):
      rows += row_def.format(y=row_id)
    hydrated_index = index.replace('SECRET', str(secret))
    hydrated_index = hydrated_index.replace('ROWS', rows)
    hydrated_index = hydrated_index.replace('MAX_ENDPOINTS', str(MAX_ENDPOINTS))
    encoded_index = bytes(hydrated_index, 'utf8')
    self.send_header('Content-Length', len(encoded_index))
    self.wfile.write(encoded_index)

  def send_endpoint_update(self):
    data = {}
    data['msg_type'] = 'endpoints'
    data['endpoints'] = ping_manager.get_endpoint_names()
    print('Sending endpoint update: ', data)
    self.wfile.write(encode_as_wire_message(data))

  def serve_stream(self):
    self.send_response(200)
    self.add_misc_headers('text/event-stream')
    self.end_headers()

    print('Beginning to serve stream...')
    #TODO: There is a problem here. If serve_stream has two callers, each caller
    #      only gets half the data. 

    self.send_endpoint_update();

    while(True):
      for event in ping_manager.get_events():
        self.wfile.write(event)
        #TODO: "I/O operation on a closed file" after machine sleeps.
        self.wfile.flush()

  def do_GET(self):
    if('favicon.ico' in self.path):
      self.send_error(404, "Resource not found")
    else:
      if(not self.check_secret()):
        print('failed to authorize:' + self.path)
      else:
        if(self.parsed_url.path == '/'):
          self.serve_index()
        elif(self.parsed_url.path == '/stream/'):
          self.serve_stream()

    self.finish()
    self.connection.close()

def run(server_class=ThreadingHTTPServer, handler_class=RequestHandler):
  #TODO: allow the port number to be dynamically assigned.
  server_address = ('', 8000) # serve on all interfaces, port 80
  httpd = server_class(server_address, handler_class)
  t = Thread(target=start_browser)
  t.run()
  print('starting httpd...')
  httpd.serve_forever()

ping_manager = PingManager(cl_args.endpoints);

run()
print('after run')
